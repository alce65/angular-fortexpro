# Angular 20-21

- [Angular 20-21](#angular-20-21)
  - [**PARTE 1. Iniciando un proyecto en Angular**](#parte-1-iniciando-un-proyecto-en-angular)
    - [Creación del proyecto](#creación-del-proyecto)
    - [Incorporación de Linters](#incorporación-de-linters)
      - [ESLint](#eslint)
      - [Prettier](#prettier)
    - [Primera aproximación a Angular](#primera-aproximación-a-angular)
      - [Revisión del Scaffolding resultante](#revisión-del-scaffolding-resultante)
        - [El workspace](#el-workspace)
        - [El proyecto de tipo aplicación](#el-proyecto-de-tipo-aplicación)
        - [El proceso de arranque (bootstrap) de la aplicación](#el-proceso-de-arranque-bootstrap-de-la-aplicación)
      - [Revisión de las operaciones básicas con el CLI (1): scaffolding y server](#revisión-de-las-operaciones-básicas-con-el-cli-1-scaffolding-y-server)
        - [Development server](#development-server)
        - [Code scaffolding. El componente Sample](#code-scaffolding-el-componente-sample)
      - [COMPONENTE (Review)](#componente-review)
      - [Revisión de las operaciones básicas con el CLI (2): build y test](#revisión-de-las-operaciones-básicas-con-el-cli-2-build-y-test)
        - [Build](#build)
        - [_Running tests unitarios_](#running-tests-unitarios)
        - [_Running tests end-to-end_](#running-tests-end-to-end)
        - [Further help](#further-help)
    - [Scripts npm y Terminales](#scripts-npm-y-terminales)

## **PARTE 1. Iniciando un proyecto en Angular**

En esta primera parte

- veremos como crear un **workspace** de Angular e incluir en el un primer proyecto de tipo **aplicación**.
- incorporaremos ayudas a la programación como **ESLint** y **Prettier** correctamente configurado
- exploraremos el **scaffolding** del proyecto creado, para conocer sus principales elementos y como funciona una aplicación de Angular
- conoceremos las principales herramientas del **CLI** para
  - desarrollar (**ng serve**)
  - construir para producción (**ng build**)
  - testar nuestra aplicación (**ng test**)
- revisaremos el concepto de **componente standalone** en Angular y como el CLI nos ayuda a generarlos

### Creación del proyecto

This project was generated with [Angular CLI](https://github.com/angular/angular-cli) version 21.0.0.

```shell
ng new ng21.taller --create-application false --ai-config copilot
cd ng21.taller
ng g app demo1 --style css -t -s -p alc --ssr false

// ng g lib alc-core --standalone -p alc
```

### Incorporación de Linters

#### ESLint

```shell
ng add @angular-eslint/schematics
```

El resultado será el siguiente

```shell
CREATE .eslintrc.json
CREATE projects/demo1/.eslintrc.json
UPDATE package.json
UPDATE angular.json
```

#### Prettier

Hasta hace poco, para que la extensión de Prettier en VSC utilice la última versión de Prettier, capaz de formatear correctamente las nuevas estructuras de control de flujo de Angular, había que instalarla como dependencia (de desarrollo) del proyecto

```shell
  npm i -D prettier
```

En las versiones recientes de VSC, esto ya no es necesario, ya que la versión de Prettier incluida en la extensión formatea correctamente.

Además es necesario que el formateador de HTML definido en los settings de VSC sea Prettier

```json
 "[html]": {
    // "editor.defaultFormatter": "vscode.html-language-features",
    "editor.defaultFormatter": "esbenp.prettier-vscode",
    "files.insertFinalNewline": true
  },
```

### Primera aproximación a Angular

#### Revisión del Scaffolding resultante

##### El workspace

Gitignore, Editorconfig y README inicial

- ng21.taller/.editorconfig (274 bytes)
- ng21.taller/.gitignore (548 bytes)
- ng21.taller/README.md (1065 bytes)

Fichero de VSC

- ng21.taller/.vscode/extensions.json (130 bytes)
- ng21.taller/.vscode/launch.json (470 bytes)
- ng21.taller/.vscode/tasks.json (938 bytes)

Ficheros de configuración

- .eslintrc.json (993 bytes)
- ng21.taller/package.json (996 bytes)
- ng21.taller/tsconfig.json (903 bytes)
- ng21.taller/angular.json (139 bytes)

##### El proyecto de tipo aplicación

Ficheros de configuración actualizados

- UPDATE angular.json (2992 bytes)
- UPDATE package.json (1044 bytes)

La carpeta del proyecto: Ficheros de configuración

- projects/demo/tsconfig.app.json (285 bytes)
- projects/demo/tsconfig.spec.json (295 bytes)
- projects/demo/.eslintrc.json (647 bytes)

La carpeta sources (src): Ficheros globales en la raíz del proyecto

- projects/demo/src/main.ts (256 bytes)
- projects/demo/src/favicon.ico (15086 bytes)
- projects/demo/src/index.html (308 bytes)
- projects/demo/src/styles.scss (81 bytes)

La carpeta app: configuración del bootstrap y las rutas

- projects/demo/src/app/app.config.ts (235 bytes)
- projects/demo/src/app/app.routes.ts (80 bytes)

La carpeta app: el componente principal (app)

- projects/demo/src/app/app.component.html (21220 bytes)
- projects/demo/src/app/app.component.spec.ts (951 bytes)
- projects/demo/src/app/app.component.ts (382 bytes)
- projects/demo/src/app/app.component.scss (0 bytes)

##### El proceso de arranque (bootstrap) de la aplicación

En projects/demo/src/ están los ficheros responsables de que exista la aplicación

```schema
index.html + styles.scss
   (definido en angular.json)
          ┕━━━━━━━> main.ts
                    (bootstrap with)
                      ┝━━━━━━━>  app.config.ts
                      ┃                ┕━━━━━━━> rutas desde app.routes.ts
                      ┕━━━━━━━> app.component.ts
                                       ┝━━━━━━━━> app.component.html
                                       ┕━━━━━━━━> app.component.scss
```

#### Revisión de las operaciones básicas con el CLI (1): scaffolding y server

##### Development server

> Ejecuta `ng serve` para iniciar un servidor de desarrollo. Navega a `http://localhost:4200/`.

Se pueden añadir diversos parámetros, por ejemplo para definir el puerto

```shell
ng serve --port 4300
```

Estando activo ng serve comprobamos como se refleja un cambio e.g. el valor del titulo almacenado en app.component. La aplicación se recargará automáticamente si modificas alguno de los archivos fuente.

##### Code scaffolding. El componente Sample

> Ejecuta `ng generate component component-name` para generar un nuevo componente.
> También puedes usar `ng generate directive|pipe|service|class|guard|interface|enum|module`.

Vemos como se generaría un componente sample en la carpeta components (también se generara)

```shell
ng g c components/sample --dry-run
```

#### COMPONENTE (Review)

En AppComponent tenemos un componente Angular formado por

- Clase + decorador
- template (html + elementos de Angular)
- estilos (css, scss, sass...)

#### Revisión de las operaciones básicas con el CLI (2): build y test

##### Build

> Ejecuta `ng build` para construir el proyecto. Los artefactos de la construcción se almacenarán en el directorio `dist/`.

Se crea la carpeta dist/demo/browser

favicon.ico
index.html

Los resultados de la compilación por parte de esbuild

main-FMCIX442.js | main | 191.64 kB | 52.66 kB
polyfills-RX4V3J3S.js | polyfills | 33.01 kB | 10.68 kB
styles-5INURTSO.css | styles | 0 bytes | 0 bytes

Este contenido es el que aparecerá en el server donde hagamos es despliegue de la aplicación (Vercel, Netlify...)

Podemos probarlo localmente, e.g. con LiveServer desde linea de comandos, si lo tenemos instalado global

```shell
npm list -g
npm i -g live-server
```

##### _Running tests unitarios_

Run `ng test` to execute the unit tests via [Vitest](https://vitest.dev/).

El test de componente fallará si hemos cambiado un valor en una propiedad sin reflejarlo en el test.
Lo corregimos y observamos la estructura de los test

El test del ejemplo ya nos muestra los **dos niveles de test**

- las propiedades del componente como clase (caja blanca)
- los elementos y comportamientos del template (caja negra: orientación UX)

Cambiamos la forma de esta última orientación sustituyendo querySelector de elemento HTML
por el debugElement de testing y sus propios métodos

```ts
// const compiled = fixture.nativeElement as HTMLElement;
// const elementH1 = compiled.querySelector('h1') as HTMLHeadingElement
const debugElement = fixture.debugElement;
const elementH1 = debugElement.query(By.css("h1"))
  .nativeElement as HTMLHeadingElement;
expect(elementH1.textContent).toContain("demo");
```

Con los cambios hechos y los test en verde, podemos hacer un **commit**

##### _Running tests end-to-end_

Ejecuta `ng e2e` para ejecutar las pruebas end-to-end. Angular CLI no incluye un framework de testing end-to-end por defecto. Puedes elegir el que mejor se adapte a tus necesidades.

```shell
ng e2e
```

La respuesta es la siguiente

```shell
Cannot find "e2e" target for the specified project.
You can add a package that implements these capabilities.

For example:
  Playwright: ng add playwright-ng-schematics
  Cypress: ng add @cypress/schematic
  Nightwatch: ng add @nightwatch/schematics
  WebdriverIO: ng add @wdio/schematics
  Puppeteer: ng add @puppeteer/ng-schematics

Would you like to add a package with "e2e" capabilities now?
  No
❯  Playwright
  Cypress
  Nightwatch
  WebdriverIO
  Puppeteer
```

Instalamos Playwright seleccionando la opción correspondiente

Se modificaan los siguientes ficheros

- .gitignore
- angular.json
- package.json

Se añaden

- playwright.config.ts
- e2e/example.spec.ts

##### Further help

Para obtener más ayuda sobre Angular CLI usa `ng help` o consulta la página de [Descripción General y Referencia de Comandos de Angular CLI](https://angular.io/cli).

### Scripts npm y Terminales

Al tener varios proyectos (aplicaciones, librerías) con sus terminales para ejecutar

- el build de desarrollo (npm start -- --project ...)
- los test (npm test -- --project ...)

puede ser util ir creando nuevos scrips en npm

Otra opción es guardar los terminales con los comandos que ejecutan,
gracias a la extensión de VSC **Restore Terminals**

Las configuraciones de esta extensión se almacenan en los settings del workspace
(.vscode/setting.json)