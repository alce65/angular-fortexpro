# Angular 20-21

- [Angular 20-21](#angular-20-21)
  - [**PARTE 2. Routing. Otros elementos: pipes y directivas.**](#parte-2-routing-otros-elementos-pipes-y-directivas)
    - [Routing. lazy loading en las rutas](#routing-lazy-loading-en-las-rutas)
      - [Rutas](#rutas)
      - [Rutas lazy](#rutas-lazy)
      - [Menu: navegaci√≥n sin recarga para una SPA](#menu-navegaci√≥n-sin-recarga-para-una-spa)
      - [Opciones del menu le√≠das desde las rutas](#opciones-del-menu-le√≠das-desde-las-rutas)
      - [Los estilos y los componentes](#los-estilos-y-los-componentes)
    - [Pipes](#pipes)
      - [Valores "localizados": Locale](#valores-localizados-locale)
      - [Creaci√≥n de Pipes personalizados](#creaci√≥n-de-pipes-personalizados)
    - [Directivas](#directivas)
      - [Creaci√≥n de directivas de atributo](#creaci√≥n-de-directivas-de-atributo)
        - [üåêDirectiva de atributo alcHighlight](#directiva-de-atributo-alchighlight)
        - [Directiva con par√°metros de entrada](#directiva-con-par√°metros-de-entrada)
        - [üëÅÔ∏è‚Äçüó®Ô∏èTest de las directiva de atributo alcHighlight](#Ô∏èÔ∏ètest-de-las-directiva-de-atributo-alchighlight)
      - [Creaci√≥n de directivas estructurales](#creaci√≥n-de-directivas-estructurales)
        - [üåêDirectiva Estructural Show](#directiva-estructural-show)
    - [Directivas y componentes din√°micos](#directivas-y-componentes-din√°micos)

## **PARTE 2. Routing. Otros elementos: pipes y directivas.**

En esta continuaci√≥n de la segunda parte veremos

- el **enrutamiento** entre componentes a los que vamos a denominar p√°gina
- la **carga diferida** (lazy loading) de esas **p√°ginas** (componentes standalone)
- los **pipes**
- las **directivas**

### Routing. lazy loading en las rutas

#### Rutas

En el fichero de rutas, a√±adimos las p√°ginas incluyendo las re-direcciones para la url vac√≠a o cualquier error

```ts
export const routes: Routes = [
  { path: "", pathMatch: "full", redirectTo: "home" },
  { path: "home", title: "Home", component: HomeComponent },
  { path: "about", title: "Acerca de", component: AboutComponent },
  { path: "**", redirectTo: "home" },
];
```

Comprobamos su funcionamiento escribiendo directamente las rutas en el navegador

El componente sample lo reubicamos en la p√°gina about
Vemos que para usar un componente es necesario **importarlo en los metadata** del otro

#### Rutas lazy

Cambiamos las rutas para que carguen la p√°ginas de forma lazy o diferida:
en el momento en el que son requeridas por primera vez

Para ello angular usa los import din√°micos soportados por el actual est√°ndar de ES

El objeto Route dispon√≠a de la propiedad loadChildren, para referirse a los m√≥dulos en carga lazy;
en las √∫ltimas versiones se a√±ade la propiedad **loadComponent**, con la misma funcionalidad para los componentes

Nos aseguramos de no importar los componentes de forma est√°tica

```ts
  { path: '', pathMatch: 'full', redirectTo: 'home' },
  {
    path: 'home',
    title: 'Home',
    loadComponent: () =>
      import('./pages/home/home.component').then((c) => c.HomeComponent),
  },

  {
    path: 'about',
    title: 'Acerca de',
    loadComponent: () =>
      import('./pages/about/about.component').then((c) => c.AboutComponent),
  },
  { path: '**', redirectTo: 'home' },
```

Si los componentes usados como p√°ginas **exportan** la clase como **default**,
no es necesario el m√©todo then para indicar el nombre del componente

```ts
  { path: '', pathMatch: 'full', redirectTo: 'home' },
  {
    path: 'home',
    title: 'Home',
    loadComponent: () =>
      import('./pages/home/home.component'),
  },

  {
    path: 'about',
    title: 'Acerca de',
    loadComponent: () =>
      import('./pages/about/about.component'),
  },
  { path: '**', redirectTo: 'home' },
```

#### Menu: navegaci√≥n sin recarga para una SPA

Creamos un componente menu

```shell
ng g c components/menu
```

Lo incorporamos en app.component, antes del router outlet

Para poder usar directivas de routing es necesario que el componente importe de Angular
el m√≥dulo responsable de esta funcionalidad, RoutingModule

```ts
@Component({
  selector: "ind-menu",
  standalone: true,
  imports: [RouterModule],
  templateUrl: "./menu.component.html",
  styleUrl: "./menu.component.scss",
})
export class MenuComponent {}
```

De esa forma, el template puede definir el comportamiento de los hiperenlaces como una navegaci√≥n SPA

```html
<a [routerLink]="'home'" routerLinkActive="link-active">Home</a>
```

Si incluimos la clase CSS en los estilos, se aplicara autom√°ticamente en el elemento del menu que est√© activo

```scss
nav {
  ul {
    list-style: none;
    display: flex;
    li {
      display: block;
      padding: 0.2rem 0.5rem;
      a {
        text-decoration: none;
        color: inherit;
      }
    }
  }
}

.link-active {
  font-weight: 500;
  font-size: 1.1rem;
  position: relative;
  top: -2px;
  transition: font-weight 2s;
  border-bottom: 1px solid;
}
```

#### Opciones del menu le√≠das desde las rutas

En lugar de definir las opciones del menu en el componente app, podemos leerlas directamente de las rutas, creando para ello una funci√≥n en el archivo de rutas

```ts
const createMenuOptions = (routes) =>
  routes
    .filter(
      (route) =>
        !route.path?.includes(":") &&
        !route.path?.includes("*") &&
        route.path !== ""
    )
    .map((route) => ({ path: route.path, label: route.title } as MenuOption));
```

Generamos las opciones del menu en el componente app ley√©ndolas de las rutas

```ts
  menuOptions: MenuOption[] = createMenuOptions(routes);
```

El haber a√±adido en las rutas la propiedad title, para luego leerla directamente en el componente,
hace que Jasmine detecte en el test las l√≠neas de llamada a los componentes como no cubiertas

Por tanto a√±adimos un test para el fichero routes, que incluir√° un componente de prueba

```ts
@Component({
  template: "",
})
class TestComponent {
  private router = inject(Router);
  goto(route: string) {
    this.router.navigate([route]);
  }
}
```

En el test

- espiaremos al m√©todo navigate del router
- llamaremos al m√©todo goto del componente
- comprobaremos que el m√©todo navigate ha sido llamado con el argumento esperado

```ts
  TestBed.configureTestingModule({
      imports: [RouterTestingModule.withRoutes(routes)],
    }).compileComponents();
    ...
    router = TestBed.inject(Router);
    navigateSpy = spyOn(router, 'navigate').and.callThrough();

    component.goto('home');
    expect(navigateSpy).toHaveBeenCalledWith(['home']);

    component.goto('about');
    expect(navigateSpy).toHaveBeenCalledWith(['about']);
```

#### Los estilos y los componentes

El fichero de estilos src/styles define los estilos generales.

En el podemos colocar las variables que ten√≠amos en el componente sample o las propiedades de main

La etiqueta main la pasamos a app.component, quit√°ndola de sample, ya que solo puede ser usada una vez.

Como vemos, el css se sigue aplicando, ya que esta en el fichero global, no vinculado a ning√∫n componente.

En el componente sample sigue existiendo la etiqueta **:host**, auto-referencia al propio componente

```scss
:host {
  min-height: 100%;
  display: flex;
  justify-content: center;
  align-items: center;
  padding: 1rem;
  position: relative;
}
```

Para comprobar la encapsulaci√≥n de los estilos, vamos al componente counter y
aplicamos el estilo al p√°rrafo de mensaje directamente en la etiqueta p, sin usar clases

Los p√°rrafos de otros componente no se ven afectados

Creamos un componente mensaje para incluirlo en counter y ver que pasa con el css en un componente hijo

```shell
  ng g c components/message
```

Tampoco le afecta el css del componente: los estilos est√°n encapsulados en su componente

Podemos ver en el inspector de las developer Tools como se consigue esto aplicando los estilos
junto con atributos en forma de hash creados por Angular durante la compilaci√≥n

Este comportamiento puede modificarse con el metadato **encapsulation** al que podemos asignar el valor **ViewEncapsulation.None**

### Pipes

Son funciones transformadoras de la salida de datos que se utilizan de forma declarativa, en los templates

Existen una serie de Built-in pipes

- DatePipe: Formats a date value according to locale rules.
- UpperCasePipe: Transforms text to all upper case.
- LowerCasePipe: Transforms text to all lower case.
- CurrencyPipe: Transforms a number to a currency string, formatted according to locale rules.
- DecimalPipe: Transforms a number into a string with a decimal point, formatted according to locale rules.
- PercentPipe: Transforms a number to a percentage string, formatted according to locale rules.
- AsyncPipe: Subscribe and unsubscribe to an asynchronous source such as an observable.
- JsonPipe: Display a component object property to the screen as JSON for debugging.

Para ver el uso de DatePipe, a√±adimos la fecha y hora en el **componente Mensaje**, que tendr√° que importar DatePipe

Este ser√≠a el aspecto inicial:

```ui
Pagina cargada Thu Jan 11 2024 14:04:40 GMT+0100 (hora est√°ndar de Europa central)
```

Y este cuando filtramos la salida para darle un formato

```ui
Pagina cargada  Thursday, January 11, 2024
```

#### Valores "localizados": Locale

Los pipes con Date, Currency, Decimal y Percent pueden recibir un par√°metro que les indica la localizaci√≥n a usar,
que debe haber sido previamente registrada en el fichero de configuraci√≥n (app.config.ts)

```ts
import localeEs from "@angular/common/locales/es";
import { registerLocaleData } from "@angular/common";

registerLocaleData(localeEs);
```

A partir de ah√≠, podemos indicas la localizaci√≥n ES en los formatos de los pipes citados

```html
<p>
  Pagina cargada el {{today | date: 'fullDate' : '' : 'ES' }} a las {{today |
  date: 'mediumTime' : '' : 'ES' }}
</p>
```

Otra posibilidad es cambiar globalmente el locale que usa la aplicaci√≥n, en el mismo app.config.ts

Importando el token LOCALE_ID y a√±adi√©ndolo al provider global de la aplicaci√≥n con un valor 'es'

```ts
import { ApplicationConfig, LOCALE_ID } from '@angular/core';
...

export const appConfig: ApplicationConfig = {
  providers: [{ provide: LOCALE_ID, useValue: 'es' }, provideRouter(routes)],
};

```

#### Creaci√≥n de Pipes personalizados

### Directivas

Las directivas son clases en Angular que permiten manipular el DOM (Document Object Model) de una manera declarativa, agregar comportamientos personalizados a los elementos y reutilizar l√≥gica en la vista.

Hay tres tipos principales de directivas en Angular:

- Directivas de atributo: Modifican la apariencia o el comportamiento de un elemento. Por ejemplo, `ngClass`, `ngStyle`.
- Directivas estructurales: Cambian la estructura del DOM. Por ejemplo, `*ngIf`, `*ngFor`.
- Componentes: T√©cnicamente son directivas con plantilla asociada.

#### Creaci√≥n de directivas de atributo

- El selector de la directiva se define como un atributo, por lo que se usa entre corchetes `[]`.
- Se suelen inyectar servicios como `ElementRef` y `Renderer2` para manipular el DOM de manera segura.
  - `ElementRef`: Permite acceder al elemento del DOM al que est√° asociada la directiva, que se encuentra en la propiedad `nativeElement`. La inyecci√≥n de dependencias de `ElementRef` proporciona una instancia asociada con el elemento anfitri√≥n (host) de la directiva.
  - `Renderer2`: Proporciona una forma segura de manipular el DOM, evitando problemas de seguridad como XSS (Cross-Site Scripting). Deber√≠a ser la √∫nica forma de manipular el DOM en Angular.

El elemento anfitri√≥n o host es el elemento del DOM al que est√° asociada la directiva. En un componente, el host es el propio componente.

Angular permite interactuar con el host de varias maneras:

- la propiedad `host` en el decorador `@Directive` o `@Component` permite definir propiedades y eventos del host.

```typescript
@Directive({
  selector: "[appMiDirectiva]",
  host: {
    "(click)": "onClick()",
    "[style.backgroundColor]": "backgroundColor",
  },
})
```

- Se pueden usar decoradores como `@HostListener` para escuchar eventos del DOM en el elemento al que est√° asociada la directiva.
- El decorador `@HostBinding` permite enlazar propiedades del host.

[medium.com/@saranipeiris17](https://medium.com/@saranipeiris17/what-is-hostbinding-in-angular-0a19873278ca)

##### üåêDirectiva de atributo alcHighlight

En este ejemplo, creamos una directiva llamada `Resaltar` que cambia el color de fondo del elemento al que se aplica cuando el mouse entra y sale del mismo.

[1]. Crear una nueva directiva usando Angular CLI:

```bash
ng g d features/proofs/directives/highlight
```

[2]. Implementar la l√≥gica de la directiva en el archivo generado.

```typescript
import { Directive, ElementRef, Renderer2, HostListener } from "@angular/core";

@Directive({
  selector: [alcHighlight],
})
export class Highlight {
  el = inject(ElementRef);
  renderer = inject(Renderer2);

  // @HostListener("mouseenter")
  onMouseEnter() {
    this.renderer.setStyle(this.el.nativeElement,cd "backgroundColor", "yellow");
  }

  // @HostListener("mouseleave")
  onMouseLeave() {
    this.renderer.removeStyle(this.el.nativeElement, "backgroundColor");
  }
}
```

Los bindings de host en el decorador `@Directive` son equivalentes a usar los decoradores `@HostListener` en los m√©todos correspondientes y se recomiendan en Angular moderno.

```ts
@Directive({
  selector: [alcHighlight],
  host: {
    "(mouseenter)": "onMouseEnter()",
    "(mouseleave)": "onMouseLeave()",
  },
})
export class Highlight {
  el = inject(ElementRef);
  renderer = inject(Renderer2);

  onMouseEnter() {
    this.renderer.setStyle(this.el.nativeElement, "backgroundColor", "yellow");
  }

  onMouseLeave() {
    this.renderer.removeStyle(this.el.nativeElement, "backgroundColor");
  }
}
```

[3]. Usar la directiva en una plantilla HTML:

Creamos un componente para probar la directiva

```shell
ng g c features/proofs/components/use-directives
```

Y en su template usamos la directiva alcHighlight

```html
<p alcHighlight>Este p√°rrafo se resaltar√° al pasar el mouse sobre √©l.</p>
```

##### Directiva con par√°metros de entrada

Como el selector de la directiva es un atributo, podemos pasarle par√°metros de entrada.

```typescript
import {
  Directive,
  ElementRef,
  Renderer2,
  HostListener,
  input,
} from "@angular/core";
@Directive({
  selector: "[alcHighlight]",
})
export class Resaltar {
  alcHighlight = input<string>();
  el = inject(ElementRef);
  renderer = inject(Renderer2);

  @HostListener("mouseenter") onMouseEnter() {
    this.renderer.setStyle(
      this.el.nativeElement,
      "backgroundColor",
      this.alcHighlight() || "yellow"
    );
  }

  @HostListener("mouseleave") onMouseLeave() {
    this.renderer.removeStyle(this.el.nativeElement, "backgroundColor");
  }
}
```

En lugar de obligarnos a que el nombre del input sea igual al del selector de la directiva, podemos usar un alias

```typescript
color = input<string>("", { alias: "alcHighlight2" });
```

##### üëÅÔ∏è‚Äçüó®Ô∏èTest de las directiva de atributo alcHighlight

Al haber usado la funci√≥n moderna `inject()`, el test pre-configurado por Angular para las directivas tiene varios errores:

- Error: NG0203: The `ElementRef` token injection failed. `inject()` function must be called from an injection context such as a constructor, a factory function, a field initializer, or a function used with `runInInjectionContext`.
- …µNotFound: NG0201: No provider found for `ElementRef`.
- Error: NG0204: Can't resolve all parameters for ElementRef: (?).
- …µNotFound: NG0201: No provider found for `Renderer2`.

Esto se debe a la forma en que Angular configura el entorno de inyecci√≥n de dependencias en los tests. Lo entenderemos cuando conozcamos los providers y sistema de inyectores.

La soluci√≥n estar√≠a en el siguiente c√≥digo:

```typescript
const renderer2Mock = {
  setStyle: vi.fn(),
  removeStyle: vi.fn(),
};

describe('Highlight', () => {
  let directive: Highlight;
  beforeEach((): void => {
    TestBed.configureTestingModule({
      providers: [
        { provide: ElementRef, useValue: new ElementRef<HTMLDivElement>(document.createElement('div')) },
        { provide: Renderer2, useValue: renderer2Mock },
      ],
    });
    TestBed.runInInjectionContext(() => {
      directive = new Highlight();
    });
  });
  it('should create an instance bind to an HTMLElement', () => {
    expect(directive).toBeTruthy();
    expect(directive.el.nativeElement).toBeInstanceOf(HTMLDivElement);
  });

  it('should response to mouse movements', () => {
    directive.onMouseEnter();
    expect(renderer2Mock.setStyle).toHaveBeenCalled();
    directive.onMouseLeave();
    expect(renderer2Mock.removeStyle).toHaveBeenCalled();
  });
});
```

Podemos comprobar que:

- la directiva queda vinculada al elemento al que se aplicara (el.nativeElement es un HTMLDivElement)
- los m√©todos onMouseEnter y onMouseLeave llaman a los m√©todos del mock de Renderer2

#### Creaci√≥n de directivas estructurales

Las directivas estructurales permiten a√±adir, manipular o eliminar elementos del DOM actuando sobre el elemento anfitri√≥n. Las directivas estructurales m√°s comunes en Angular son `*ngIf`, `*ngFor` y `*ngSwitch`.

En realidad la sintaxis con asterisco (`*`) es un az√∫car sint√°ctico que Angular convierte en una forma m√°s expl√≠cita usando `ng-template`. Por ejemplo, la directiva `*ngIf` se traduce a:

```html
<ng-template [ngIf]="condition">
  <div>Contenido visible</div>
</ng-template>
```

En las directivas estructurales, la inyecci√≥n de dependencias nos proporciona dos servicios clave:

- `TemplateRef`: Representa una plantilla embebida en el DOM. Permite acceder al contenido de la plantilla que se va a manipular.
- `ViewContainerRef`: Representa un contenedor donde se pueden insertar vistas. Permite crear, eliminar o manipular vistas dentro del contenedor.

Usando el m√©todo `createEmbeddedView` de `ViewContainerRef`, podemos crear una instancia de la plantilla representada por `TemplateRef` y a√±adirla al contenedor. 

##### üåêDirectiva Estructural Show

[1]. Crear una nueva directiva usando Angular CLI:

```bash
ng g d features/proofs/directives/show
```

[2]. Implementar la l√≥gica de la directiva en el archivo generado:

```typescript
import { Directive, Input, TemplateRef, ViewContainerRef } from "@angular/core";
@Directive({
  selector: "[appMostrar]",
})
export class Mostrar {
  private hasView = false;

  private templateRef: TemplateRef<any> = inject(TemplateRef);
  private viewContainer: ViewContainerRef = inject(ViewContainerRef);


  @Input() set appMostrar(condition: boolean) {
    if (condition && !this.hasView) {
      this.viewContainer.createEmbeddedView(this.templateRef);
      this.hasView = true;
    } else if (!condition && this.hasView) {
      this.viewContainer.clear();
      this.hasView = false;
    }
  }
}
```

[3]. Usar la directiva en una plantilla HTML:

```html
<div *appMostrar="isVisible">Contenido visible</div>
<button (click)="isVisible = !isVisible">Toggle Visibilidad</button>
```

En este ejemplo, la directiva `*appMostrar` muestra u oculta el contenido basado en la condici√≥n booleana `isVisible`.

En realidad existe un ngTemplate impl√≠cito que Angular crea detr√°s de escena para manejar la directiva estructural.

```html
<ng-template [appMostrar]="isVisible">
  <div>Contenido visible</div>
</ng-template>
```

La directiva utiliza `TemplateRef` para acceder a la plantilla (ng-template) y `ViewContainerRef` para manipular la vista.
Concretamente el m√©todo `createEmbeddedView` crea una instancia de la plantilla y la inserta en el contenedor de vistas, mientras que `clear` elimina todas las vistas del contenedor.

Si refactorizamos el c√≥digo usando input signals (la funci√≥n input), la directiva quedar√≠a as√≠:

```typescript
import { Directive, Input, TemplateRef, ViewContainerRef } from "@angular/core";
@Directive({
  selector: "[appMostrar]",
})
export class Mostrar {
  private hasView = false;

  private templateRef: TemplateRef<any> = inject(TemplateRef);
  private viewContainer: ViewContainerRef = inject(ViewContainerRef);

  appMostrar = input<boolean>();
  constructor() {
    effect(() => {
      if (this.appMostrar() && !this.hasView) {
        this.viewContainer.createEmbeddedView(this.templateRef);
        this.hasView = true;
      } else if (!this.appMostrar() && this.hasView) {
        this.viewContainer.clear();
        this.hasView = false;
      }
    });
  }

  // ngOnChanges() {
  //   if (this.appMostrar() && !this.hasView) {
  //     this.viewContainer.createEmbeddedView(this.templateRef);
  //     this.hasView = true;
  //   } else if (!this.appMostrar() && this.hasView) {
  //     this.viewContainer.clear();
  //     this.hasView = false;
  //   }
  // }
}
```

### Directivas y componentes din√°micos
